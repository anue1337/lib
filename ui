local SevereUI = {}
SevereUI.__index = SevereUI

-- Configurações padrão
SevereUI.DefaultConfig = {
    title = "SevereUI Window",
    position = {20, 20},
    size = {300, 350},
    theme = {
        background = {40, 40, 40},
        foreground = {50, 50, 50},
        accent = {245, 245, 245},
        text = {255, 255, 255},
        border = {215, 215, 215},
        highlight = {70, 70, 70}
    },
    transparency = 1,
    draggable = true,
    font = 4,
    textSize = 15
}

-- Armazenar todas as instâncias de janelas criadas
SevereUI.Windows = {}

-- Criar uma nova janela
function SevereUI.new(config)
    local window = {}
    setmetatable(window, SevereUI)
    
    -- Mesclar configuração padrão com configuração fornecida
    window.config = {}
    for k, v in pairs(SevereUI.DefaultConfig) do
        window.config[k] = (config and config[k] ~= nil) and config[k] or v
    end
    
    -- Propriedades da janela
    window.visible = true
    window.elements = {}
    window.tabs = {}
    window.currentTab = nil
    window.dragging = false
    window.dragOffset = {0, 0}
    
    -- Inicializar a janela
    window:Initialize()
    
    -- Adicionar à lista de janelas
    table.insert(SevereUI.Windows, window)
    
    return window
end

-- Inicializar a janela
function SevereUI:Initialize()
    local screenDimensions = getscreendimensions()
    
    -- Criar o frame principal (borda externa)
    self.frame = Drawing.new("Square")
    self.frame.Filled = true
    self.frame.Visible = self.visible
    self.frame.Size = self.config.size
    self.frame.Position = self.config.position
    self.frame.Color = self.config.theme.border
    self.frame.Transparency = self.config.transparency
    
    -- Criar o frame secundário (fundo)
    self.innerFrame = Drawing.new("Square")
    self.innerFrame.Filled = true
    self.innerFrame.Visible = self.visible
    self.innerFrame.Size = {self.frame.Size.x - 2, self.frame.Size.y - 2}
    self.innerFrame.Position = {self.frame.Position.x + 1, self.frame.Position.y + 1}
    self.innerFrame.Color = self.config.theme.background
    self.innerFrame.Transparency = self.config.transparency
    
    -- Criar a barra de título
    self.titleBar = Drawing.new("Square")
    self.titleBar.Filled = true
    self.titleBar.Visible = self.visible
    self.titleBar.Size = {self.innerFrame.Size.x, 25}
    self.titleBar.Position = {self.innerFrame.Position.x, self.innerFrame.Position.y}
    self.titleBar.Color = self.config.theme.foreground
    self.titleBar.Transparency = self.config.transparency
    
    -- Criar o texto do título
    self.titleText = Drawing.new("Text")
    self.titleText.Text = self.config.title
    self.titleText.Visible = self.visible
    self.titleText.Center = false
    self.titleText.Position = {self.titleBar.Position.x + 10, self.titleBar.Position.y + 5}
    self.titleText.Color = self.config.theme.text
    self.titleText.Size = self.config.textSize
    self.titleText.Font = self.config.font
    self.titleText.Transparency = self.config.transparency
    
    -- Criar o contêiner do conteúdo
    self.contentContainer = Drawing.new("Square")
    self.contentContainer.Filled = true
    self.contentContainer.Visible = self.visible
    self.contentContainer.Size = {
        self.innerFrame.Size.x, 
        self.innerFrame.Size.y - self.titleBar.Size.y
    }
    self.contentContainer.Position = {
        self.innerFrame.Position.x,
        self.innerFrame.Position.y + self.titleBar.Size.y
    }
    self.contentContainer.Color = self.config.theme.background
    self.contentContainer.Transparency = self.config.transparency
    
    -- Configurar funcionalidade de arrastar se habilitada
    if self.config.draggable then
        self:SetupDraggable()
    end
end

function SevereUI:MouseInArea(area, deadzone)
    local mousePos = getmouseposition()
    
    if deadzone ~= nil then
        if mousePos.x > area[1] and mousePos.y > area[2] and mousePos.x < area[3] and mousePos.y < area[4] then
            if mousePos.x > deadzone[1] and mousePos.y > deadzone[2] and mousePos.x < deadzone[3] and mousePos.y < deadzone[4] then
                return false
            else
                return true
            end
        else
            return false
        end
    else
        if mousePos.x > area[1] and mousePos.y > area[2] and mousePos.x < area[3] and mousePos.y < area[4] then
            return true
        else
            return false
        end
    end
end

-- Gerenciador centralizado de eventos de mouse
SevereUI.Mouse = {
    lastClick = 0,
    isLeftPressed = false,
    hasLeftClicked = false
}

-- Função para atualizar o estado do mouse
function SevereUI:UpdateMouseState()
    local leftPressed = isleftpressed()
    
    -- Detectar clique (transição de não pressionado para pressionado)
    SevereUI.Mouse.hasLeftClicked = leftPressed and not SevereUI.Mouse.isLeftPressed
    
    -- Atualizar estado de pressionado
    SevereUI.Mouse.isLeftPressed = leftPressed
    
    -- Registrar timestamp do último clique para evitar múltiplos cliques
    if SevereUI.Mouse.hasLeftClicked then
        SevereUI.Mouse.lastClick = os.clock()
    end
    
    return SevereUI.Mouse
end

-- Função para verificar se um clique ocorreu em uma área, com proteção anti-duplo-clique
function SevereUI:CheckClickInArea(area, deadzone, cooldown)
    cooldown = cooldown or 0.2 -- Tempo mínimo entre cliques (em segundos)
    
    local mouse = self:UpdateMouseState()
    
    if mouse.hasLeftClicked and (os.clock() - mouse.lastClick) > cooldown then
        return self:MouseInArea(area, deadzone)
    end
    
    return false
end

-- Função para gerenciar a ordem Z das janelas (trazendo a janela clicada para frente)
function SevereUI:ManageWindowZOrder(window)
    -- Remover a janela da lista
    for i, win in ipairs(SevereUI.Windows) do
        if win == window then
            table.remove(SevereUI.Windows, i)
            break
        end
    end
    
    -- Adicionar a janela no topo da lista (maior Z-index)
    table.insert(SevereUI.Windows, window)
end

-- Modificar o método de inicialização para configurar o gerenciador de eventos global
local oldInitialize = SevereUI.Initialize
function SevereUI:Initialize()
    oldInitialize(self)
    
    -- Configurar o gerenciador de eventos global se ainda não estiver configurado
    if not SevereUI.EventManagerActive then
        spawn(function()
            SevereUI.EventManagerActive = true
            while true do
                -- Atualizar estado do mouse para todas as janelas
                SevereUI:UpdateMouseState()
                wait(0.01)
            end
        end)
    end
end

-- Configurar funcionalidade de arrastar
-- Substituir a função SetupDraggable por esta versão melhorada
function SevereUI:SetupDraggable()
    spawn(function()
        local lastDragCheck = 0
        
        while true do
            if not self.visible then
                wait(0.1)
                continue
            end
            
            local mousePos = getmouseposition()
            local currentTime = os.clock()
            
            -- Área da barra de título
            local titleBarArea = {
                self.titleBar.Position.x,
                self.titleBar.Position.y,
                self.titleBar.Position.x + self.titleBar.Size.x,
                self.titleBar.Position.y + self.titleBar.Size.y
            }
            
            -- Verificar se o mouse está sobre a barra de título
            local overTitleBar = self:MouseInArea(titleBarArea)
            
            -- Gerenciar o início do arrasto com debounce para evitar problemas
            if overTitleBar and isleftpressed() and not self.dragging and (currentTime - lastDragCheck > 0.05) then
                -- Verificar se esta janela deve estar na frente
                self:ManageWindowZOrder(self)
                
                self.dragging = true
                self.dragOffset = {
                    mousePos.x - self.frame.Position.x,
                    mousePos.y - self.frame.Position.y
                }
                
                lastDragCheck = currentTime
            end
            
            -- Terminar arrasto
            if not isleftpressed() and self.dragging then
                self.dragging = false
                lastDragCheck = currentTime
            end
            
            -- Atualizar posição durante arrasto com limitações de taxa
            if self.dragging then
                local newX = mousePos.x - self.dragOffset[1]
                local newY = mousePos.y - self.dragOffset[2]
                
                -- Mover todos os elementos
                self:SetPosition({newX, newY})
            end
            
            wait(0.01)
        end
    end)
end

-- Adicionar função para gerenciar a ordem Z das janelas
function SevereUI:ManageWindowZOrder(window)
    -- Verificar se a janela já está na lista
    local index = nil
    for i, win in ipairs(SevereUI.Windows) do
        if win == window then
            index = i
            break
        end
    end
    
    -- Se a janela estiver na lista, movê-la para o final (maior Z-index)
    if index then
        table.remove(SevereUI.Windows, index)
        table.insert(SevereUI.Windows, window)
    end
end

-- Definir a posição da janela
function SevereUI:SetPosition(position)
    local offsetX = position[1] - self.frame.Position.x
    local offsetY = position[2] - self.frame.Position.y
    
    -- Atualizar posição do frame principal
    self.frame.Position = position
    
    -- Atualizar posições de todos os outros elementos
    self.innerFrame.Position = {self.frame.Position.x + 1, self.frame.Position.y + 1}
    self.titleBar.Position = {self.innerFrame.Position.x, self.innerFrame.Position.y}
    self.titleText.Position = {self.titleBar.Position.x + 10, self.titleBar.Position.y + 5}
    self.contentContainer.Position = {
        self.innerFrame.Position.x,
        self.innerFrame.Position.y + self.titleBar.Size.y
    }
    
    -- Atualizar posições de todos os elementos filhos
    self:UpdateElementPositions(offsetX, offsetY)
end

-- Atualizar posições de elementos filho quando a janela se move
function SevereUI:UpdateElementPositions(offsetX, offsetY)
    -- Atualizar todos os elementos filhos
    for _, element in pairs(self.elements) do
        if element.type == "button" then
            element.background.Position = {
                element.background.Position.x + offsetX,
                element.background.Position.y + offsetY
            }
            element.label.Position = {
                element.label.Position.x + offsetX,
                element.label.Position.y + offsetY
            }
        elseif element.type == "toggle" then
            element.background.Position = {
                element.background.Position.x + offsetX,
                element.background.Position.y + offsetY
            }
            element.label.Position = {
                element.label.Position.x + offsetX,
                element.label.Position.y + offsetY
            }
        elseif element.type == "slider" then
            element.background.Position = {
                element.background.Position.x + offsetX,
                element.background.Position.y + offsetY
            }
            element.label.Position = {
                element.label.Position.x + offsetX,
                element.label.Position.y + offsetY
            }
            element.handle.Position = {
                element.handle.Position.x + offsetX,
                element.handle.Position.y + offsetY
            }
            element.fill.Position = {
                element.fill.Position.x + offsetX,
                element.fill.Position.y + offsetY
            }
        elseif element.type == "dropdown" then
            element.header.Position = {
                element.header.Position.x + offsetX,
                element.header.Position.y + offsetY
            }
            element.label.Position = {
                element.label.Position.x + offsetX,
                element.label.Position.y + offsetY
            }
            element.valueText.Position = {
                element.valueText.Position.x + offsetX,
                element.valueText.Position.y + offsetY
            }
            element.arrow.Position = {
                element.arrow.Position.x + offsetX,
                element.arrow.Position.y + offsetY
            }
            element.optionsContainer.Position = {
                element.optionsContainer.Position.x + offsetX,
                element.optionsContainer.Position.y + offsetY
            }
            for _, option in ipairs(element.optionElements) do
                option.background.Position = {
                    option.background.Position.x + offsetX,
                    option.background.Position.y + offsetY
                }
                option.text.Position = {
                    option.text.Position.x + offsetX,
                    option.text.Position.y + offsetY
                }
            end
        elseif element.type == "label" then
            element.textObject.Position = {
                element.textObject.Position.x + offsetX,
                element.textObject.Position.y + offsetY
            }
        end
    end
    
    -- Atualizar abas
    for _, tab in pairs(self.tabs) do
        tab.button.Position = {
            tab.button.Position.x + offsetX,
            tab.button.Position.y + offsetY
        }
        tab.buttonText.Position = {
            tab.buttonText.Position.x + offsetX,
            tab.buttonText.Position.y + offsetY
        }
        tab.container.Position = {
            tab.container.Position.x + offsetX,
            tab.container.Position.y + offsetY
        }
        
        -- Atualizar elementos da aba
        for _, element in pairs(tab.elements) do
            if element.type == "button" then
                element.background.Position = {
                    element.background.Position.x + offsetX,
                    element.background.Position.y + offsetY
                }
                element.label.Position = {
                    element.label.Position.x + offsetX,
                    element.label.Position.y + offsetY
                }
            elseif element.type == "toggle" then
                element.background.Position = {
                    element.background.Position.x + offsetX,
                    element.background.Position.y + offsetY
                }
                element.label.Position = {
                    element.label.Position.x + offsetX,
                    element.label.Position.y + offsetY
                }
            elseif element.type == "slider" then
                element.background.Position = {
                    element.background.Position.x + offsetX,
                    element.background.Position.y + offsetY
                }
                element.label.Position = {
                    element.label.Position.x + offsetX,
                    element.label.Position.y + offsetY
                }
                element.handle.Position = {
                    element.handle.Position.x + offsetX,
                    element.handle.Position.y + offsetY
                }
                element.fill.Position = {
                    element.fill.Position.x + offsetX,
                    element.fill.Position.y + offsetY
                }
            elseif element.type == "dropdown" then
                element.header.Position = {
                    element.header.Position.x + offsetX,
                    element.header.Position.y + offsetY
                }
                element.label.Position = {
                    element.label.Position.x + offsetX,
                    element.label.Position.y + offsetY
                }
                element.valueText.Position = {
                    element.valueText.Position.x + offsetX,
                    element.valueText.Position.y + offsetY
                }
                element.arrow.Position = {
                    element.arrow.Position.x + offsetX,
                    element.arrow.Position.y + offsetY
                }
                element.optionsContainer.Position = {
                    element.optionsContainer.Position.x + offsetX,
                    element.optionsContainer.Position.y + offsetY
                }
                for _, option in ipairs(element.optionElements) do
                    option.background.Position = {
                        option.background.Position.x + offsetX,
                        option.background.Position.y + offsetY
                    }
                    option.text.Position = {
                        option.text.Position.x + offsetX,
                        option.text.Position.y + offsetY
                    }
                end
            elseif element.type == "label" then
                element.textObject.Position = {
                    element.textObject.Position.x + offsetX,
                    element.textObject.Position.y + offsetY
                }
            end
        end
    end
end

-- Adicionar uma função de renderização master que gerencia a ordem Z
function SevereUI:RenderAll()
    self:UpdateDeadZones()
    self:UpdateNotifications()
    
    for i, window in ipairs(self.Windows) do
        if window.visible then
            window:Render()
            self:UpdateTooltips()
        end
    end
    
    self:UpdateNotifications()
end

-- Nova função de renderização para uma janela específica
function SevereUI:Render()
    if not self.visible then
        return
    end
    
    -- Desenhar os elementos base da janela
    -- Os elementos já têm suas propriedades Visible configuradas corretamente
    
    -- Renderizar elementos filhos
    for _, element in pairs(self.elements) do
        if element.visible and element.Render then
            element:Render()
        end
    end
    
    -- Renderizar a aba atual se houver
    if self.currentTab then
        -- Os elementos da aba já têm suas propriedades Visible configuradas corretamente
        
        -- Renderizar elementos da aba
        for _, element in pairs(self.currentTab.elements) do
            if element.visible and element.Render then
                element:Render()
            end
        end
    end
end

-- Modificar a função Init para incluir o sistema RenderAll
function SevereUI.Init()
    -- Configure o loop de renderização global
    spawn(function()
        while true do
            SevereUI:RenderAll()
            wait(0.01) -- 100 FPS máximo para renderização
        end
    end)
    
    -- Configurar o gerenciador de eventos
    SevereUI:UpdateMouseState()
end

-- Mostrar a janela
function SevereUI:Show()
    self.visible = true
    self.frame.Visible = true
    self.innerFrame.Visible = true
    self.titleBar.Visible = true
    self.titleText.Visible = true
    self.contentContainer.Visible = true
    
    -- Mostrar todos os elementos filhos
    for _, element in pairs(self.elements) do
        if element.Show then
            element:Show()
        end
    end
end

-- Esconder a janela
function SevereUI:Hide()
    self.visible = false
    self.frame.Visible = false
    self.innerFrame.Visible = false
    self.titleBar.Visible = false
    self.titleText.Visible = false
    self.contentContainer.Visible = false
    
    -- Esconder todos os elementos filhos
    for _, element in pairs(self.elements) do
        if element.Hide then
            element:Hide()
        end
    end
end

-- Destruir a janela e todos os seus elementos
function SevereUI:Destroy()
    -- Remover da lista de janelas
    for i, window in ipairs(SevereUI.Windows) do
        if window == self then
            table.remove(SevereUI.Windows, i)
            break
        end
    end
    
    -- Destruir todos os elementos de desenho
    self.frame:Remove()
    self.innerFrame:Remove()
    self.titleBar:Remove()
    self.titleText:Remove()
    self.contentContainer:Remove()
    
    -- Destruir todos os elementos filhos
    for _, element in pairs(self.elements) do
        if element.Destroy then
            element:Destroy()
        end
    end
end

-- Adicionar uma nova aba
function SevereUI:AddTab(name)
    -- Criar a aba
    local tab = {
        name = name,
        elements = {},
        container = nil,
        button = nil,
        visible = false,
        parent = self
    }
    
    -- Calcular a posição para o botão da aba
    local tabIndex = #self.tabs + 1
    local tabButtonWidth = 80
    local tabButtonHeight = 25
    local tabButtonX = self.contentContainer.Position.x + (tabIndex - 1) * tabButtonWidth
    local tabButtonY = self.contentContainer.Position.y
    
    -- Criar o botão da aba
    tab.button = Drawing.new("Square")
    tab.button.Filled = true
    tab.button.Visible = self.visible
    tab.button.Size = {tabButtonWidth, tabButtonHeight}
    tab.button.Position = {tabButtonX, tabButtonY}
    tab.button.Color = (tabIndex == 1) and self.config.theme.foreground or self.config.theme.background
    tab.button.Transparency = self.config.transparency
    
    -- Criar o texto do botão da aba
    tab.buttonText = Drawing.new("Text")
    tab.buttonText.Text = name
    tab.buttonText.Visible = self.visible
    tab.buttonText.Center = true
    tab.buttonText.Position = {
        tab.button.Position.x + tab.button.Size.x / 2,
        tab.button.Position.y + tab.button.Size.y / 2 - self.config.textSize / 2
    }
    tab.buttonText.Color = self.config.theme.text
    tab.buttonText.Size = self.config.textSize
    tab.buttonText.Font = self.config.font
    tab.buttonText.Transparency = self.config.transparency
    
    -- Criar o contêiner de conteúdo da aba
    tab.container = Drawing.new("Square")
    tab.container.Filled = true
    tab.container.Visible = tabIndex == 1 and self.visible
    tab.container.Size = {
        self.contentContainer.Size.x,
        self.contentContainer.Size.y - tabButtonHeight
    }
    tab.container.Position = {
        self.contentContainer.Position.x,
        self.contentContainer.Position.y + tabButtonHeight
    }
    tab.container.Color = self.config.theme.background
    tab.container.Transparency = self.config.transparency
    
    -- Adicionar funções à aba
    tab.Show = function()
        tab.visible = true
        tab.container.Visible = self.visible
        tab.button.Color = self.config.theme.foreground
        
        -- Mostrar todos os elementos filhos da aba
        for _, element in pairs(tab.elements) do
            if element.Show then
                element:Show()
            end
        end
    end
    
    tab.Hide = function()
        tab.visible = false
        tab.container.Visible = false
        tab.button.Color = self.config.theme.background
        
        -- Esconder todos os elementos filhos da aba
        for _, element in pairs(tab.elements) do
            if element.Hide then
                element:Hide()
            end
        end
    end
    
    tab.Destroy = function()
        tab.button:Remove()
        tab.buttonText:Remove()
        tab.container:Remove()
        
        -- Destruir todos os elementos filhos da aba
        for _, element in pairs(tab.elements) do
            if element.Destroy then
                element:Destroy()
            end
        end
    end
    
    -- Adicionar à lista de abas
    table.insert(self.tabs, tab)
    
    -- Se for a primeira aba, torná-la ativa
    if tabIndex == 1 then
        self.currentTab = tab
        tab.visible = true
    end
    
    -- Configurar clique na aba
    spawn(function()
        while self.visible do
            if not self.visible then
                wait(0.1)
                continue
            end
            
            local mousePos = getmouseposition()
            
            -- Verificar se o mouse está sobre o botão da aba
            local overTabButton = (
                mousePos.x >= tab.button.Position.x and
                mousePos.x <= tab.button.Position.x + tab.button.Size.x and
                mousePos.y >= tab.button.Position.y and
                mousePos.y <= tab.button.Position.y + tab.button.Size.y
            )
            
            -- Mudar para esta aba quando clicada
            if overTabButton and isleftclicked() then
                -- Esconder a aba atual
                if self.currentTab then
                    self.currentTab:Hide()
                end
                
                -- Mostrar esta aba
                self.currentTab = tab
                tab:Show()
                
                -- Esperar um momento para evitar acionamentos múltiplos
                wait(0.2)
            end
            
            wait(0.01)
        end
    end)
    
    return tab
end

-- Função para adicionar elementos à janela ou aba
function SevereUI:AddElement(element)
    table.insert(self.elements, element)
    return element
end

-- Criar um botão
-- Substituir a configuração de clique no botão por esta versão melhorada
function SevereUI:CreateButton(options)
    local parent = options.parent or self.currentTab or self
    local container = parent.container or self.contentContainer
    
    -- Opções padrão
    options = options or {}
    options.text = options.text or "Button"
    options.position = options.position or {10, 10}  -- Relative to parent
    options.size = options.size or {100, 30}
    options.callback = options.callback or function() end
    
    -- Criar o botão
    local button = {
        type = "button",
        text = options.text,
        callback = options.callback,
        parent = parent,
        visible = true,
        isHovered = false
    }
    
    -- Posição absoluta
    local absolutePosition = {
        container.Position.x + options.position[1],
        container.Position.y + options.position[2]
    }
    
    -- Criar o background do botão
    button.background = Drawing.new("Square")
    button.background.Filled = true
    button.background.Visible = parent.visible and self.visible
    button.background.Size = options.size
    button.background.Position = absolutePosition
    button.background.Color = self.config.theme.foreground
    button.background.Transparency = self.config.transparency
    
    -- Criar o texto do botão
    button.label = Drawing.new("Text")
    button.label.Text = options.text
    button.label.Visible = parent.visible and self.visible
    button.label.Center = true
    button.label.Position = {
        absolutePosition[1] + options.size[1] / 2,
        absolutePosition[2] + options.size[2] / 2 - self.config.textSize / 2
    }
    button.label.Color = self.config.theme.text
    button.label.Size = self.config.textSize
    button.label.Font = self.config.font
    button.label.Transparency = self.config.transparency

    -- Obter a área clicável do botão
    button.getClickArea = function()
        return {
            button.background.Position.x,
            button.background.Position.y,
            button.background.Position.x + button.background.Size.x,
            button.background.Position.y + button.background.Size.y
        }
    end
    
    -- Criar funções para o botão
    button.Show = function()
        button.visible = true
        button.background.Visible = parent.visible and self.visible
        button.label.Visible = parent.visible and self.visible
    end
    
    button.Hide = function()
        button.visible = false
        button.background.Visible = false
        button.label.Visible = false
    end
    
    button.Destroy = function()
        button.background:Remove()
        button.label:Remove()
    end
    
    -- Configurar interação com o botão usando o sistema centralizado
    spawn(function()
        while true do
            if not self.visible or not parent.visible then
                wait(0.1)
                continue
            end
            
            local mousePos = getmouseposition()
            local buttonArea = button.getClickArea()
            
            -- Verificar se o mouse está sobre o botão
            local isHovered = self:MouseInArea(buttonArea)
            
            -- Atualizar estado de hover e aparência
            if isHovered ~= button.isHovered then
                button.isHovered = isHovered
                button.background.Color = isHovered and self.config.theme.highlight or self.config.theme.foreground
            end
            
            -- Verificar clique com debounce
            if button.isHovered and self.Mouse.hasLeftClicked and (os.clock() - self.Mouse.lastClick < 0.2) then
                button.callback()
                self.Mouse.lastClick = os.clock() -- Resetar o cooldown do clique
            end
            
            wait(0.01)
        end
    end)
    
    -- Adicionar à lista de elementos
    table.insert(parent.elements, button)
    
    return button
end

-- Criar um Toggle
function SevereUI:CreateToggle(options)
    local parent = options.parent or self.currentTab or self
    local container = parent.container or self.contentContainer
    
    -- Opções padrão
    options = options or {}
    options.text = options.text or "Toggle"
    options.position = options.position or {10, 10}
    options.size = options.size or {20, 20}
    options.default = options.default or false
    options.callback = options.callback or function() end
    
    -- Criar o toggle
    local toggle = {
        type = "toggle",
        text = options.text,
        value = options.default,
        callback = options.callback,
        parent = parent,
        visible = true
    }
    
    -- Posição absoluta
    local absolutePosition = {
        container.Position.x + options.position[1],
        container.Position.y + options.position[2]
    }
    
    -- Criar o background do toggle
    toggle.background = Drawing.new("Square")
    toggle.background.Filled = true
    toggle.background.Visible = parent.visible and self.visible
    toggle.background.Size = options.size
    toggle.background.Position = absolutePosition
    toggle.background.Color = toggle.value and self.config.theme.accent or self.config.theme.foreground
    toggle.background.Transparency = self.config.transparency
    
    -- Criar o texto do toggle
    toggle.label = Drawing.new("Text")
    toggle.label.Text = options.text
    toggle.label.Visible = parent.visible and self.visible
    toggle.label.Center = false
    toggle.label.Position = {
        absolutePosition[1] + options.size[1] + 10,
        absolutePosition[2] + options.size[2] / 2 - self.config.textSize / 2
    }
    toggle.label.Color = self.config.theme.text
    toggle.label.Size = self.config.textSize
    toggle.label.Font = self.config.font
    toggle.label.Transparency = self.config.transparency
    
    -- Criar funções para o toggle
    toggle.Show = function()
        toggle.visible = true
        toggle.background.Visible = parent.visible and self.visible
        toggle.label.Visible = parent.visible and self.visible
    end
    
    toggle.Hide = function()
        toggle.visible = false
        toggle.background.Visible = false
        toggle.label.Visible = false
    end
    
    toggle.Destroy = function()
        toggle.background:Remove()
        toggle.label:Remove()
    end
    
    toggle.SetValue = function(value)
        toggle.value = value
        toggle.background.Color = value and self.config.theme.accent or self.config.theme.foreground
        toggle.callback(value)
    end
    
    toggle.GetValue = function()
        return toggle.value
    end
    
    -- Configurar clique no toggle
    spawn(function()
        while true do
            if not self.visible or not parent.visible then
                wait(0.1)
                continue
            end
            
            local mousePos = getmouseposition()
            
            -- Verificar se o mouse está sobre o toggle
            local overToggle = (
                mousePos.x >= toggle.background.Position.x and
                mousePos.x <= toggle.background.Position.x + toggle.background.Size.x and
                mousePos.y >= toggle.background.Position.y and
                mousePos.y <= toggle.background.Position.y + toggle.background.Size.y
            )
            
            -- Mudar estado quando clicado
            if overToggle and isleftclicked() then
                toggle.SetValue(not toggle.value)
                wait(0.2)  -- Evitar múltiplos cliques
            end
            
            wait(0.01)
        end
    end)
    
    -- Adicionar à lista de elementos
    table.insert(parent.elements, toggle)
    
    return toggle
end

function SevereUI:UpdateDeadZones()
    if #self.Windows == 0 then return end
    
    -- Obter janela com maior Z-index
    local topWindow = self.Windows[#self.Windows]
    local pos = topWindow.frame.Position
    local size = topWindow.frame.Size
    
    -- Definir área de dead zone dinâmica
    self.DeadZone = {
        pos[1], pos[2],
        pos[1] + size[1],
        pos[2] + size[2]
    }
end

function SevereUI:IsInDeadZone(x, y)
    if not self.DeadZone then return false end
    return x >= self.DeadZone[1] and y >= self.DeadZone[2] and
           x <= self.DeadZone[3] and y <= self.DeadZone[4]
end

function SevereUI:CreateTooltip(element, text)
    element.tooltip = {
        text = text,
        active = false,
        drawing = {
            bg = Drawing.new("Square"),
            text = Drawing.new("Text")
        }
    }
    
    -- Configurar estilo
    local theme = self.DefaultConfig.theme
    element.tooltip.drawing.bg.Color = theme.background
    element.tooltip.drawing.bg.Transparency = 0.8
    element.tooltip.drawing.text.Color = theme.text
    element.tooltip.drawing.text.Size = self.DefaultConfig.textSize
end

function SevereUI:UpdateTooltips()
    local mousePos = getmouseposition()
    
    for _, window in ipairs(self.Windows) do
        for _, element in ipairs(window.elements) do
            if element.tooltip and element:MouseInArea() then
                -- Posicionar tooltip
                local offset = 15
                element.tooltip.drawing.bg.Position = {mousePos.x + offset, mousePos.y + offset}
                element.tooltip.drawing.text.Position = {mousePos.x + offset + 5, mousePos.y + offset + 3}
                
                -- Atualizar texto
                element.tooltip.drawing.text.Text = element.tooltip.text
                
                -- Calcular tamanho
                local textWidth = Drawing.CalcTextWidth(element.tooltip.text)
                element.tooltip.drawing.bg.Size = {textWidth + 10, self.DefaultConfig.textSize + 6}
                
                -- Mostrar
                element.tooltip.drawing.bg.Visible = true
                element.tooltip.drawing.text.Visible = true
            else
                if element.tooltip then
                    element.tooltip.drawing.bg.Visible = false
                    element.tooltip.drawing.text.Visible = false
                end
            end
        end
    end
end

function SevereUI:CreateColorPicker(options)
    local picker = {
        type = "colorpicker",
        value = options.default or {255, 255, 255},
        open = false,
        rainbow = false,
        elements = {}
    }
    
    -- Elementos de desenho
    picker.elements.main = Drawing.new("Square")
    picker.elements.selector = Drawing.new("Circle")
    
    -- Configurar aparência
    picker.elements.main.Filled = true
    picker.elements.selector.Thickness = 2
    
    function picker:UpdateColor()
        if self.rainbow then
            self.value = self:CalculateRainbow()
        end
        self.elements.main.Color = self.value
    end
    
    function picker:CalculateRainbow()
        local hue = (os.clock() * 0.5) % 1
        local r, g, b = HSVToRGB(hue, 1, 1)
        return {r * 255, g * 255, b * 255}
    end
    
    return picker
end

function SevereUI:SetToggleKey(window, key)
    window.toggleKey = key:upper()
    
    spawn(function()
        while true do
            if iskeypressed(window.toggleKey) then
                window.visible = not window.visible
                self:ManageWindowZOrder(window)
                wait(0.5) -- Debounce
            end
            wait()
        end
    end)
end

function SevereUI:Notify(text, duration)
    local notification = {
        lines = {},
        startTime = os.clock(),
        duration = duration or 5,
        elements = {}
    }
    
    -- Quebrar texto em linhas
    for line in text:gmatch("[^\n]+") do
        table.insert(notification.lines, line)
    end
    
    -- Criar elementos de desenho
    local height = #notification.lines * (self.DefaultConfig.textSize + 2) + 10
    notification.elements.bg = Drawing.new("Square")
    notification.elements.bg.Color = self.DefaultConfig.theme.background
    notification.elements.bg.Transparency = 0.9
    
    notification.elements.texts = {}
    for i, line in ipairs(notification.lines) do
        local text = Drawing.new("Text")
        text.Text = line
        text.Color = self.DefaultConfig.theme.text
        text.Size = self.DefaultConfig.textSize
        table.insert(notification.elements.texts, text)
    end
    
    table.insert(self.Notifications, notification)
end

function SevereUI:UpdateNotifications()
    local currentTime = os.clock()
    
    for i = #self.Notifications, 1, -1 do
        local notif = self.Notifications[i]
        local progress = (currentTime - notif.startTime) / notif.duration
        
        if progress >= 1 then
            -- Remover elementos
            notif.elements.bg:Remove()
            for _, text in ipairs(notif.elements.texts) do
                text:Remove()
            end
            table.remove(self.Notifications, i)
        else
            -- Atualizar posições
            local yPos = 10 + (i-1) * 60
            notif.elements.bg.Position = {10, yPos}
            
            for j, text in ipairs(notif.elements.texts) do
                text.Position = {15, yPos + 5 + (j-1)*(self.DefaultConfig.textSize + 2)}
            end
        end
    end
end

function SevereUI:CreateElement(elementType, config)
    local element = Drawing.new(elementType)
    
    -- Mapear configurações
    if elementType == "Text" then
        element.Text = config.text or ""
        element.Font = config.font or self.DefaultConfig.font
        element.Center = config.center or false
    elseif elementType == "Square" then
        element.Filled = config.filled or true
        element.Thickness = config.thickness or 1
    end
    
    -- Propriedades comuns
    element.Visible = config.visible or false
    element.Color = config.color or self.DefaultConfig.theme.text
    element.Transparency = config.transparency or self.DefaultConfig.transparency
    
    return element
end

-- Criar um Slider
function SevereUI:CreateSlider(options)
    local parent = options.parent or self.currentTab or self
    local container = parent.container or self.contentContainer
    
    -- Opções padrão
    options = options or {}
    options.text = options.text or "Slider"
    options.position = options.position or {10, 10}
    options.size = options.size or {150, 15}
    options.min = options.min or 0
    options.max = options.max or 100
    options.default = options.default or options.min
    options.increment = options.increment or 1
    options.callback = options.callback or function() end
    
    -- Garantir que o valor padrão esteja dentro dos limites
    options.default = math.max(options.min, math.min(options.max, options.default))
    
    -- Criar o slider
    local slider = {
        type = "slider",
        text = options.text,
        value = options.default,
        min = options.min,
        max = options.max,
        increment = options.increment,
        callback = options.callback,
        parent = parent,
        visible = true,
        dragging = false
    }
    
    -- Posição absoluta
    local absolutePosition = {
        container.Position.x + options.position[1],
        container.Position.y + options.position[2]
    }
    
    -- Criar o texto do slider
    slider.label = Drawing.new("Text")
    slider.label.Text = options.text .. ": " .. tostring(slider.value)
    slider.label.Visible = parent.visible and self.visible
    slider.label.Center = false
    slider.label.Position = {
        absolutePosition[1],
        absolutePosition[2] - self.config.textSize - 5
    }
    slider.label.Color = self.config.theme.text
    slider.label.Size = self.config.textSize
    slider.label.Font = self.config.font
    slider.label.Transparency = self.config.transparency
    
    -- Criar o background do slider
    slider.background = Drawing.new("Square")
    slider.background.Filled = true
    slider.background.Visible = parent.visible and self.visible
    slider.background.Size = options.size
    slider.background.Position = absolutePosition
    slider.background.Color = self.config.theme.foreground
    slider.background.Transparency = self.config.transparency
    
    -- Calcular a posição inicial do handle
    local handlePosition = ((slider.value - slider.min) / (slider.max - slider.min)) * (options.size[1] - 10)
    
    -- Criar o handle do slider
    slider.handle = Drawing.new("Square")
    slider.handle.Filled = true
    slider.handle.Visible = parent.visible and self.visible
    slider.handle.Size = {10, options.size[2] + 5}
    slider.handle.Position = {
        absolutePosition[1] + handlePosition,
        absolutePosition[2] - 2.5
    }
slider.handle.Color = self.config.theme.accent
slider.handle.Transparency = self.config.transparency

-- Criar o fill do slider
slider.fill = Drawing.new("Square")
slider.fill.Filled = true
slider.fill.Visible = parent.visible and self.visible
slider.fill.Size = {handlePosition, options.size[2]}
slider.fill.Position = absolutePosition
slider.fill.Color = {
    self.config.theme.accent[1] * 0.7,
    self.config.theme.accent[2] * 0.7,
    self.config.theme.accent[3] * 0.7
}
slider.fill.Transparency = self.config.transparency

-- Criar funções para o slider
slider.Show = function()
    slider.visible = true
    slider.background.Visible = parent.visible and self.visible
    slider.label.Visible = parent.visible and self.visible
    slider.handle.Visible = parent.visible and self.visible
    slider.fill.Visible = parent.visible and self.visible
end

slider.Hide = function()
    slider.visible = false
    slider.background.Visible = false
    slider.label.Visible = false
    slider.handle.Visible = false
    slider.fill.Visible = false
end

slider.Destroy = function()
    slider.background:Remove()
    slider.label:Remove()
    slider.handle:Remove()
    slider.fill:Remove()
end

slider.SetValue = function(value)
    -- Arredondar para o incremento mais próximo
    value = math.floor((value - slider.min) / slider.increment + 0.5) * slider.increment + slider.min
    
    -- Limitar o valor
    value = math.max(slider.min, math.min(slider.max, value))
    
    -- Atualizar valor
    slider.value = value
    
    -- Atualizar texto
    slider.label.Text = options.text .. ": " .. tostring(value)
    
    -- Atualizar posição do handle e do fill
    local handlePosition = ((value - slider.min) / (slider.max - slider.min)) * (options.size[1] - 10)
    slider.handle.Position = {
        absolutePosition[1] + handlePosition,
        absolutePosition[2] - 2.5
    }
    slider.fill.Size = {handlePosition, options.size[2]}
    
    -- Acionar callback
    slider.callback(value)
end

slider.GetValue = function()
    return slider.value
end

-- Configurar interação com o slider
spawn(function()
    while true do
        if not self.visible or not parent.visible then
            wait(0.1)
            continue
        end
        
        local mousePos = getmouseposition()
        
        -- Verificar se o mouse está sobre o slider
        local overSlider = (
            mousePos.x >= slider.background.Position.x and
            mousePos.x <= slider.background.Position.x + slider.background.Size.x and
            mousePos.y >= slider.background.Position.y and
            mousePos.y <= slider.background.Position.y + slider.background.Size.y
        )
        
        -- Verificar se o mouse está sobre o handle
        local overHandle = (
            mousePos.x >= slider.handle.Position.x and
            mousePos.x <= slider.handle.Position.x + slider.handle.Size.x and
            mousePos.y >= slider.handle.Position.y and
            mousePos.y <= slider.handle.Position.y + slider.handle.Size.y
        )
        
        -- Iniciar arrasto
        if (overSlider or overHandle) and isleftpressed() and not slider.dragging then
            slider.dragging = true
        end
        
        -- Terminar arrasto
        if not isleftpressed() and slider.dragging then
            slider.dragging = false
        end
        
        -- Atualizar posição durante arrasto
        if slider.dragging then
            local relativeX = math.max(0, math.min(options.size[1] - 10, mousePos.x - absolutePosition[1]))
            local newValue = slider.min + (relativeX / (options.size[1] - 10)) * (slider.max - slider.min)
            slider.SetValue(newValue)
        end
        
        wait(0.01)
    end
end)

-- Adicionar à lista de elementos
table.insert(parent.elements, slider)

return slider
end

-- Criar um Label (texto estático)
function SevereUI:CreateLabel(options)
    local parent = options.parent or self.currentTab or self
    local container = parent.container or self.contentContainer
    
    -- Opções padrão
    options = options or {}
    options.text = options.text or "Label"
    options.position = options.position or {10, 10}
    options.center = options.center or false
    
    -- Criar o label
    local label = {
        type = "label",
        text = options.text,
        parent = parent,
        visible = true
    }
    
    -- Posição absoluta
    local absolutePosition = {
        container.Position.x + options.position[1],
        container.Position.y + options.position[2]
    }
    
    -- Criar o texto do label
    label.textObject = Drawing.new("Text")
    label.textObject.Text = options.text
    label.textObject.Visible = parent.visible and self.visible
    label.textObject.Center = options.center
    label.textObject.Position = absolutePosition
    label.textObject.Color = self.config.theme.text
    label.textObject.Size = self.config.textSize
    label.textObject.Font = self.config.font
    label.textObject.Transparency = self.config.transparency
    
    -- Criar funções para o label
    label.Show = function()
        label.visible = true
        label.textObject.Visible = parent.visible and self.visible
    end
    
    label.Hide = function()
        label.visible = false
        label.textObject.Visible = false
    end
    
    label.Destroy = function()
        label.textObject:Remove()
    end
    
    label.SetText = function(text)
        label.text = text
        label.textObject.Text = text
    end
    
    label.GetText = function()
        return label.text
    end
    
    -- Adicionar à lista de elementos
    table.insert(parent.elements, label)
    
    return label
end

-- Criar um Dropdown
function SevereUI:CreateDropdown(options)
    local parent = options.parent or self.currentTab or self
    local container = parent.container or self.contentContainer
    
    -- Opções padrão
    options = options or {}
    options.text = options.text or "Dropdown"
    options.position = options.position or {10, 10}
    options.size = options.size or {150, 30}
    options.options = options.options or {"Option 1", "Option 2", "Option 3"}
    options.default = options.default or options.options[1]
    options.callback = options.callback or function() end
    
    -- Criar o dropdown
    local dropdown = {
        type = "dropdown",
        text = options.text,
        options = options.options,
        value = options.default,
        open = false,
        callback = options.callback,
        parent = parent,
        visible = true,
        elements = {}
    }
    
    -- Posição absoluta
    local absolutePosition = {
        container.Position.x + options.position[1],
        container.Position.y + options.position[2]
    }
    
    -- Criar o texto do dropdown
    dropdown.label = Drawing.new("Text")
    dropdown.label.Text = options.text
    dropdown.label.Visible = parent.visible and self.visible
    dropdown.label.Center = false
    dropdown.label.Position = {
        absolutePosition[1],
        absolutePosition[2] - self.config.textSize - 5
    }
    dropdown.label.Color = self.config.theme.text
    dropdown.label.Size = self.config.textSize
    dropdown.label.Font = self.config.font
    dropdown.label.Transparency = self.config.transparency
    
    -- Criar o background do dropdown (header)
    dropdown.header = Drawing.new("Square")
    dropdown.header.Filled = true
    dropdown.header.Visible = parent.visible and self.visible
    dropdown.header.Size = options.size
    dropdown.header.Position = absolutePosition
    dropdown.header.Color = self.config.theme.foreground
    dropdown.header.Transparency = self.config.transparency
    
    -- Criar o texto do valor atual
    dropdown.valueText = Drawing.new("Text")
    dropdown.valueText.Text = dropdown.value
    dropdown.valueText.Visible = parent.visible and self.visible
    dropdown.valueText.Center = false
    dropdown.valueText.Position = {
        absolutePosition[1] + 10,
        absolutePosition[2] + options.size[2] / 2 - self.config.textSize / 2
    }
    dropdown.valueText.Color = self.config.theme.text
    dropdown.valueText.Size = self.config.textSize
    dropdown.valueText.Font = self.config.font
    dropdown.valueText.Transparency = self.config.transparency
    
    -- Criar o ícone de seta para baixo
    dropdown.arrow = Drawing.new("Text")
    dropdown.arrow.Text = "▼"
    dropdown.arrow.Visible = parent.visible and self.visible
    dropdown.arrow.Center = false
    dropdown.arrow.Position = {
        absolutePosition[1] + options.size[1] - 20,
        absolutePosition[2] + options.size[2] / 2 - self.config.textSize / 2
    }
    dropdown.arrow.Color = self.config.theme.text
    dropdown.arrow.Size = self.config.textSize
    dropdown.arrow.Font = self.config.font
    dropdown.arrow.Transparency = self.config.transparency
    
    -- Criar o container de opções (invisível inicialmente)
    dropdown.optionsContainer = Drawing.new("Square")
    dropdown.optionsContainer.Filled = true
    dropdown.optionsContainer.Visible = false
    dropdown.optionsContainer.Size = {
        options.size[1],
        (#options.options * options.size[2])
    }
    dropdown.optionsContainer.Position = {
        absolutePosition[1],
        absolutePosition[2] + options.size[2]
    }
    dropdown.optionsContainer.Color = self.config.theme.background
    dropdown.optionsContainer.Transparency = self.config.transparency
    
    -- Criar as opções
    dropdown.optionElements = {}
    for i, option in ipairs(options.options) do
        local optionBackground = Drawing.new("Square")
        optionBackground.Filled = true
        optionBackground.Visible = false
        optionBackground.Size = {options.size[1], options.size[2]}
        optionBackground.Position = {
            dropdown.optionsContainer.Position.x,
            dropdown.optionsContainer.Position.y + (i-1) * options.size[2]
        }
        optionBackground.Color = self.config.theme.foreground
        optionBackground.Transparency = self.config.transparency
        
        local optionText = Drawing.new("Text")
        optionText.Text = option
        optionText.Visible = false
        optionText.Center = false
        optionText.Position = {
            optionBackground.Position.x + 10,
            optionBackground.Position.y + options.size[2] / 2 - self.config.textSize / 2
        }
        optionText.Color = self.config.theme.text
        optionText.Size = self.config.textSize
        optionText.Font = self.config.font
        optionText.Transparency = self.config.transparency
        
        table.insert(dropdown.optionElements, {
            background = optionBackground,
            text = optionText,
            value = option
        })
    end
    
    -- Criar funções para o dropdown
    dropdown.Show = function()
        dropdown.visible = true
        dropdown.header.Visible = parent.visible and self.visible
        dropdown.label.Visible = parent.visible and self.visible
        dropdown.valueText.Visible = parent.visible and self.visible
        dropdown.arrow.Visible = parent.visible and self.visible
        
        if dropdown.open then
            dropdown.optionsContainer.Visible = parent.visible and self.visible
            for _, option in ipairs(dropdown.optionElements) do
                option.background.Visible = parent.visible and self.visible
                option.text.Visible = parent.visible and self.visible
            end
        end
    end
    
    dropdown.Hide = function()
        dropdown.visible = false
        dropdown.header.Visible = false
        dropdown.label.Visible = false
        dropdown.valueText.Visible = false
        dropdown.arrow.Visible = false
        dropdown.optionsContainer.Visible = false
        
        for _, option in ipairs(dropdown.optionElements) do
            option.background.Visible = false
            option.text.Visible = false
        end
    end
    
    dropdown.Destroy = function()
        dropdown.header:Remove()
        dropdown.label:Remove()
        dropdown.valueText:Remove()
        dropdown.arrow:Remove()
        dropdown.optionsContainer:Remove()
        
        for _, option in ipairs(dropdown.optionElements) do
            option.background:Remove()
            option.text:Remove()
        end
    end
    
    dropdown.SetValue = function(value)
        -- Verificar se o valor existe nas opções
        local valueExists = false
        for _, option in ipairs(dropdown.options) do
            if option == value then
                valueExists = true
                break
            end
        end
        
        if not valueExists then
            warn("Value '" .. tostring(value) .. "' does not exist in dropdown options.")
            return
        end
        
        -- Atualizar valor
        dropdown.value = value
        dropdown.valueText.Text = value
        
        -- Acionar callback
        dropdown.callback(value)
    end
    
    dropdown.GetValue = function()
        return dropdown.value
    end
    
    dropdown.ToggleOptions = function()
        dropdown.open = not dropdown.open
        
        -- Atualizar seta
        dropdown.arrow.Text = dropdown.open and "▲" or "▼"
        
        -- Mostrar/esconder opções
        dropdown.optionsContainer.Visible = dropdown.open and parent.visible and self.visible
        
        for _, option in ipairs(dropdown.optionElements) do
            option.background.Visible = dropdown.open and parent.visible and self.visible
            option.text.Visible = dropdown.open and parent.visible and self.visible
        end
    end
    
    -- Configurar interação com o dropdown
    spawn(function()
        while true do
            if not self.visible or not parent.visible then
                if dropdown.open then
                    dropdown.ToggleOptions()
                end
                wait(0.1)
                continue
            end
            
            local mousePos = getmouseposition()
            
            -- Verificar se o mouse está sobre o header
            local overHeader = (
                mousePos.x >= dropdown.header.Position.x and
                mousePos.x <= dropdown.header.Position.x + dropdown.header.Size.x and
                mousePos.y >= dropdown.header.Position.y and
                mousePos.y <= dropdown.header.Position.y + dropdown.header.Size.y
            )
            
            -- Alterar cor do header quando hover
            if overHeader then
                dropdown.header.Color = self.config.theme.highlight
                
                -- Mostrar/esconder opções quando clicado
                if isleftclicked() then
                    dropdown.ToggleOptions()
                    wait(0.2)  -- Evitar múltiplos cliques
                end
            else
                dropdown.header.Color = self.config.theme.foreground
            end
            
            -- Processar opções se estiver aberto
            if dropdown.open then
                -- Verificar se clicou fora do dropdown
                local clickedOutside = isleftclicked() and not (
                    mousePos.x >= dropdown.optionsContainer.Position.x and
                    mousePos.x <= dropdown.optionsContainer.Position.x + dropdown.optionsContainer.Size.x and
                    mousePos.y >= dropdown.header.Position.y and
                    mousePos.y <= dropdown.optionsContainer.Position.y + dropdown.optionsContainer.Size.y
                )
                
                if clickedOutside then
                    dropdown.ToggleOptions()
                    wait(0.2)  -- Evitar múltiplos cliques
                end
                
                -- Verificar cliques nas opções
                for i, option in ipairs(dropdown.optionElements) do
                    local overOption = (
                        mousePos.x >= option.background.Position.x and
                        mousePos.x <= option.background.Position.x + option.background.Size.x and
                        mousePos.y >= option.background.Position.y and
                        mousePos.y <= option.background.Position.y + option.background.Size.y
                    )
                    
                    -- Alterar cor da opção quando hover
                    if overOption then
                        option.background.Color = self.config.theme.highlight
                        
                        -- Selecionar opção quando clicada
                        if isleftclicked() then
                            dropdown.SetValue(option.value)
                            dropdown.ToggleOptions()
                            wait(0.2)  -- Evitar múltiplos cliques
                        end
                    else
                        option.background.Color = self.config.theme.foreground
                    end
                end
            end
            
            wait(0.01)
        end
    end)
    
    -- Adicionar à lista de elementos
    table.insert(parent.elements, dropdown)
    
    return dropdown
end

return SevereUI
